---
title: 字符串编辑距离
date: 2018-07-01 15:20:23
tags: [Algorithm]
categories: [Algorithm]
mathjax: true
toc: true
description: 编辑距离问题:给出两个字符串S1、S2，对S1进行插入、删除、替换的操作，每次只能操作一个字符，最少操作多少步，使其等于S2。
---

### 问题定义
**编辑距离问题:** 给出两个字符串$S_1$、$S_2$，对$S_1$进行插入、删除、替换的操作，每次只能操作一个字符，最少操作多少步，使其等于$S_2$。

**示例:**
$S_1 = abc$, $S_2 = badc$，abc插入字符b变为 babc，字符b替换为字符d变为 badc，估最少操作两步。

### 问题分析

典型的动态规划问题， 命$dp_{i,j}$表示子串$S_1[1:i]$和$S_2[1:j]$之间的编辑距离， 显然有： 
$$dp_{i,0} = i$$
$$dp_{0,j} = j$$ 

对于更一般的情况， 有如下地推公式： 

$$dp_{i,j} = \begin {cases} dp_{i-1,j-1}, & \text {if $S_1[i] = S_2[j]$ } \\ \min\{dp_{i-1,j-1}, dp_{i,j-1}, dp_{i-1,j}\} + 1, & \text{if $S_1[i] \neq S_2[j]$ }  \end{cases}$$

于是有最终编辑距离： 

$$Result = dp_{len(S_1),len(S_2)}$$

其中$len(S)$表示字符串$S$的长度。 

### 动态规划

下面给出最基本的Java实现： 

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length(); 
        int len2 = word2.length(); 
        
        if (len1 == 0) {
            return len2; 
        }
        
        if (len2 == 0) {
            return len1; 
        }
        
        int[][] dp = new int[len1 + 1][len2 + 1]; 
        
        for (int i = 0; i <= len1; i ++) {
            dp[i][0] = i; 
        }
        
        for (int i = 0; i <= len2; i ++) {
            dp[0][i] = i;
        }
        
        for (int i = 1; i <= len1; i ++) {
            for (int j = 1; j <= len2; j ++) {
                if(word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1]; 
                }
                else {
                    dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j]) + 1; 
                    dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + 1); 
                }
            }
        }
        
        return dp[len1][len2]; 
    }
}
```

### 存储优化

