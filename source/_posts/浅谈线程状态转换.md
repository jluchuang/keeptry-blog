---
title: 浅谈线程状态转换
date: 2019-01-27 14:16:34
tags: [Java]
categories: [Java]
toc: true
---

Java JVM线程可以处于以下状态中： 

- NEW: 至今尚未启动的线程处于这种状态； 
- RUNNABLE: 正在Java虚拟机中执行的线程处于这种状态； 
- BLOCKED: 受阻塞并等待另一个线程来执行某一特定操作的线程处于这种状态； 
- WAITING: 无限期等待另一个线程来执行某一特定操作的线程处于这种状态； 
- TIMED_WAITING: 等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态； 
- TERMINATED: 已退出的线程处于这种状态； 

## 状态转换

![](https://wx1.sinaimg.cn/mw690/7c35df9bly1fzniw2xbkqj20v70gnmz1.jpg)

### 状态转换说明

1. 新建(new)：新创建了一个线程对象。

2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

3. 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

## 实例

```java
package concurrent.thread;

import java.util.concurrent.locks.ReentrantLock;

public class ThreadFun {

    private static final Object l = new Object();
    private static ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Thread t = new Thread(() -> {
            System.out.println("Thread State When Running: " + Thread.currentThread().getState());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized(l) {
                System.out.println("Thread State After Get Lock on l: " + Thread.currentThread().getState());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        });

        System.out.println("New Thread State: " + t.getState());

        t.start();

        Thread.sleep(500);
        System.out.println("Thread State When Sleep: " + t.getState());

        synchronized (l) {
            Thread.sleep(3000);
            System.out.println("Thread State When Blocked: " + t.getState());
        }

        t.join();
        System.out.println("Thread State After Run: " + t.getState());

    }
}
```

示例输出： 

```
New Thread State: NEW
Thread State When Running: RUNNABLE
Thread State When Sleep: TIMED_WAITING
Thread State When Blocked: BLOCKED
Thread State After Get Lock on l: RUNNABLE
Thread State After Run: TERMINATED
```

## 参考引用

- [1] [枚举 Thread.State](http://www.cjsdn.net/doc/jdk50/java/lang/Thread.State.html)
- [2] [一张图让你看懂JAVA线程间的状态转换](https://my.oschina.net/mingdongcheng/blog/139263)
